import librosa
import numpy as np
import pandas as pd
import os
import time

start_time = time.time()

def extract_features(audio_path, file_name):
    # Load the audio file
    y, sr = librosa.load(audio_path, sr=None)
    
    # Length of the audio (in seconds)
    length = librosa.get_duration(y=y, sr=sr)
    
    # Chroma STFT (mean and variance)
    chroma_stft = librosa.feature.chroma_stft(y=y, sr=sr)
    chroma_stft_mean = np.mean(chroma_stft)
    chroma_stft_var = np.var(chroma_stft)
    
    # RMS Energy (mean and variance)
    rms = librosa.feature.rms(y=y)
    rms_mean = np.mean(rms)
    rms_var = np.var(rms)
    
    # Spectral Centroid (mean and variance)
    spectral_centroid = librosa.feature.spectral_centroid(y=y, sr=sr)
    spectral_centroid_mean = np.mean(spectral_centroid)
    spectral_centroid_var = np.var(spectral_centroid)
    
    # Spectral Bandwidth (mean and variance)
    spectral_bandwidth = librosa.feature.spectral_bandwidth(y=y, sr=sr)
    spectral_bandwidth_mean = np.mean(spectral_bandwidth)
    spectral_bandwidth_var = np.var(spectral_bandwidth)
    
    # Spectral Rolloff (mean and variance)
    rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr, roll_percent=0.85)
    rolloff_mean = np.mean(rolloff)
    rolloff_var = np.var(rolloff)
    
    # Zero Crossing Rate (mean and variance)
    zero_crossing_rate = librosa.feature.zero_crossing_rate(y=y)
    zero_crossing_rate_mean = np.mean(zero_crossing_rate)
    zero_crossing_rate_var = np.var(zero_crossing_rate)
    
    # Harmony (mean and variance)
    harmony = librosa.effects.harmonic(y=y)
    harmony_mean = np.mean(harmony)
    harmony_var = np.var(harmony)
   
    
    # Tempo (mean)
    onset_env = librosa.onset.onset_strength(y=y, sr=sr)
    tempo, z = librosa.beat.beat_track(onset_envelope=onset_env, sr=sr)

    tempo = tempo[0]
    
    # MFCCs (mean and variance for the first 20 coefficients)
    mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=20)
    mfcc_means = np.mean(mfccs, axis=1)
    mfcc_vars = np.var(mfccs, axis=1)
    
    # Return a dictionary of all the features
    features = {
        "filename": file_name,
        "length": length,
        "chroma_stft_mean": chroma_stft_mean,
        "chroma_stft_var": chroma_stft_var,
        "rms_mean": rms_mean,
        "rms_var": rms_var,
        "spectral_centroid_mean": spectral_centroid_mean,
        "spectral_centroid_var": spectral_centroid_var,
        "spectral_bandwidth_mean": spectral_bandwidth_mean,
        "spectral_bandwidth_var": spectral_bandwidth_var,
        "rolloff_mean": rolloff_mean,
        "rolloff_var": rolloff_var,
        "zero_crossing_rate_mean": zero_crossing_rate_mean,
        "zero_crossing_rate_var": zero_crossing_rate_var,
        "harmony_mean": harmony_mean,
        "harmony_var": harmony_var,
        "tempo": tempo,
        # Add MFCC means and variances
        **{f"mfcc{i+1}_mean": mfcc_means[i] for i in range(len(mfcc_means))},
        **{f"mfcc{i+1}_var": mfcc_vars[i] for i in range(len(mfcc_vars))},
    }
    
    return features


# Folder paths and genre names
base_path = 'datasets/gtzan/genres_original'
genres = ['blues', 'classical', 'country', 'disco', 'hiphop', 'jazz', 'metal', 'pop', 'reggae', 'rock']
features_list = []

# Loop through each genre and file
for g in genres:
    for i in range(100):
        num = f"000{str(i)}"
        if i < 10:
            num = f"0000{str(i)}"
        
        # Skip problematic file (jazz genre, file 54)
        if i == 54 and g == "jazz":
            continue
        
        file_name = f"/{g}/{g}.{num}.wav"
        full_path = base_path + file_name
        print(f"Processing: {full_path}")
        
        # Extract features
        feature = extract_features(full_path, file_name)
        feature['label'] = g  # Add genre label
        features_list.append(feature)

# Convert the features to a DataFrame
df = pd.DataFrame(features_list)

# Save the features to a CSV
df.to_csv('datasets/gtzan_processed_30s/processed_features.csv', index=False)

# Print how long it took
print(f"Processing time: {time.time() - start_time:.2f} seconds")
